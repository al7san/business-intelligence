# شرح تفصيلي جداً: Dimensional Modeling مع أمثلة عملية

---

## الجزء الأول: المقدمة والأساسيات

### لماذا Dimensional Modeling؟

تخيل أنك تدير متجر ملابس:

**النظام التشغيلي (OLTP - Operational)**:
```
كل عملية بيع تُسجل بالتفاصيل الدقيقة:
- معرّف بيع فريد
- تاريخ ووقت بالثانية
- معرّف الموظف
- معرّف العميل
- معرّف المنتج
- الكمية
- السعر
- الخصم
- الضرائب
- الإجمالي
```

هذا النظام مثالي للعمليات اليومية: معالجة الطلبات، إدارة المخزون، إصدار الفواتير.

**لكن المدير يقول**: "أريد معرفة الأرقام التالية":
- كم بعنا الشهر الماضي؟
- أي المنتجات الأكثر مبيعاً؟
- من أكثر عميل ينفق أموال؟
- هل هناك أنماط في أوقات البيع؟
- أي الفروع تحقق أفضل أداء؟

**المشكلة**: 
النظام التشغيلي معقد جداً، مصمم للسرعة في العمليات وليس للتحليل.

**الحل**: Dimensional Modeling
- نأخذ البيانات من النظام التشغيلي
- نعيد تنظيمها بطريقة تركز على **التحليل**
- نجعل الاستعلامات سريعة وسهلة

---

## الجزء الثاني: Facts بالتفصيل الممل (لكن مهم!)

### مثال عملي: متجر ملابس

#### شكل Fact Table:

```
Fact_Store_Sales:
┌─────┬─────────┬──────────┬──────────┬─────────┬──────┐
│ ID  │DateKey  │StoreKey  │ProductKey│SalesQty │Amount│
├─────┼─────────┼──────────┼──────────┼─────────┼──────┤
│ 1   │20240115 │ S001     │ P234     │ 2       │ 150  │
│ 2   │20240115 │ S001     │ P567     │ 1       │ 250  │
│ 3   │20240115 │ S002     │ P234     │ 5       │ 375  │
│ 4   │20240116 │ S001     │ P890     │ 3       │ 450  │
└─────┴─────────┴──────────┴──────────┴─────────┴──────┘

المفاتيح الأجنبية:
- DateKey: يشير إلى Dim_Date
- StoreKey: يشير إلى Dim_Store
- ProductKey: يشير إلى Dim_Product

الـ Measures (الأرقام الفعلية):
- SalesQty: كمية المبيعات
- Amount: قيمة المبيعات بالريال
```

#### شرح كل جزء:

**1. المفاتيح (Foreign Keys)**:
```
DateKey = 20240115 
→ ابحث في Dim_Date عن التاريخ الموافق
→ ستجد كل معلومات هذا التاريخ (اليوم من الأسبوع، الشهر، الربع، إلخ)

StoreKey = S001
→ ابحث في Dim_Store
→ ستجد: اسم المتجر، المدينة، المنطقة، المدير

ProductKey = P234
→ ابحث في Dim_Product
→ ستجد: اسم المنتج، اللون، الحجم، الماركة، الفئة
```

**2. Grain (درجة التفاصيل)**:
```
كل صف = عملية بيع واحدة
هذا هو أقل مستوى تفاصيل:
- بيعة واحدة = سجل واحد
- (وليس: مجموع البيعات اليومية في متجر واحد)

لماذا؟ لأنك قد تحتاج لاحقاً لتفاصيل أكثر (كل ساعة، كل موظف، إلخ)
```

**3. المفتاح الأساسي (Primary Key)**:
```
ما الذي يجعل الصف فريداً؟

ليس DateKey وحده (قد يكون في نفس اليوم أكثر من عملية)
ليس StoreKey وحده (أكثر من متجر)
ليس ProductKey وحده (نفس المنتج قد يُباع عدة مرات)

المفتاح = مجموعة المفاتيح:
DateKey + StoreKey + ProductKey + ... 

في هذا المثال:
(20240115 + S001 + P234) = فريدة
لكن (20240115 + S001 + P234) مرة أخرى = مشكلة!

الحل: إما:
أ) أضف مفاتيح أكثر (مثل: الساعة، الموظف)
ب) استخدم Surrogate Key جديد (رقم 1، 2، 3...)
```

---

### أنواع Facts: شرح عميق جداً

#### النوع الأول: Additive Facts (قابلة للجمع)

**التعريف البسيط**: يمكنك جمعها في أي اتجاه والنتيجة منطقية.

**مثال عملي**: كمية المبيعات

```
جدول المبيعات اليومية:
┌──────────┬────────┬────────────┐
│ التاريخ  │ المتجر │ SalesQty   │
├──────────┼────────┼────────────┤
│15-01-2024│ S001   │ 50 وحدة    │
│15-01-2024│ S002   │ 30 وحدة    │
│16-01-2024│ S001   │ 40 وحدة    │
│16-01-2024│ S002   │ 20 وحدة    │
└──────────┴────────┴────────────┘

استعلامات ممكنة:

1) مجموع المبيعات في 15-01:
   SUM = 50 + 30 = 80 وحدة ✓ صحيح

2) مجموع مبيعات S001:
   SUM = 50 + 40 = 90 وحدة ✓ صحيح

3) المجموع الكلي:
   SUM = 50 + 30 + 40 + 20 = 140 وحدة ✓ صحيح

الخلاصة:
يمكنك جمع SalesQty عبر أي dimension
(أي تاريخ، أي متجر، أي منتج)
والنتيجة صحيحة تحليلياً
```

**أمثلة أخرى من Additive**:
- إجمالي الإيرادات (Revenue)
- عدد الطلبات
- عدد الموظفين المعينين
- عدد الشكاوى المستلمة

---

#### النوع الثاني: Semi-Additive Facts (قابل للجمع جزئياً)

**التعريف**: يمكن جمعه في بعض الأبعاد فقط، لا كلها.

**مثال 1: رصيد الحساب البنكي** (الأهم!)

```
جدول الأرصدة الشهرية:
┌────────┬────────────┐
│ الشهر  │ الرصيد     │
├────────┼────────────┤
│ يناير  │ 10,000 ر.س │
│ فبراير │ 12,000 ر.س │
│ مارس   │ 15,000 ر.س │
└────────┴────────────┘

الاستعلام الخاطئ:
SUM = 10,000 + 12,000 + 15,000 = 37,000 ر.س ✗ خطأ كبير!

هذا يعني: "مجموع أرصدتي على 3 أشهر"؟
لا! هذا بلا معنى!

الاستعلام الصحيح:
AVG = (10,000 + 12,000 + 15,000) / 3 = 12,333.33 ر.س ✓ صحيح
(هذا يعني: "متوسط رصيدي على 3 أشهر")

أو تأخذ رصيد نقطة زمنية واحدة:
الرصيد في آخر مارس = 15,000 ر.س ✓ صحيح
```

**لماذا؟**
- الرصيد يُقاس في **نقطة زمنية** (آخر الشهر)
- ليس تراكمي (مثل الكمية المباعة)
- جمع الأرصدة = بلا معنى

**مثال 2: عدد الطلاب في الفصل**

```
جدول الحضور اليومي:
┌───────┬──────────────┐
│التاريخ│عدد الطلاب    │
├───────┼──────────────┤
│الأحد  │ 30 طالب      │
│الإثنين│ 32 طالب      │
│الثلاثاء│28 طالب      │
└───────┴──────────────┘

الخطأ:
SUM = 30 + 32 + 28 = 90 طالب ✗
هل معنى هذا أن عندنا 90 طالب؟ لا! في الواقع عندنا ~30 طالب

الصحيح:
AVG = 90 / 3 = 30 طالب ✓
(متوسط الحضور هو 30 طالب)
```

**متى يمكن تجميع Semi-Additive؟**
- يمكن جمع عبر الأبعاد **غير الزمنية** (مثل: متجر، قسم، فرع)
- لا يمكن جمع عبر **الزمن** (تاريخ، شهر، سنة)

**مثال**:
```
أرصدة عملاء مختلفة (نهاية يناير):
┌──────────┬────────────┐
│ العميل   │ الرصيد     │
├──────────┼────────────┤
│أحمد      │ 5,000 ر.س  │
│خديجة     │ 3,000 ر.س  │
│علي       │ 7,000 ر.س  │
└──────────┴────────────┘

المجموع = 5,000 + 3,000 + 7,000 = 15,000 ر.س ✓ صحيح!
(إجمالي الأرصدة لجميع العملاء في يناير)

لكن:
┌──────────┬──────────┬────────────┐
│ العميل   │ الشهر    │ الرصيد     │
├──────────┼──────────┼────────────┤
│أحمد      │ يناير    │ 5,000 ر.س  │
│أحمد      │ فبراير   │ 6,000 ر.س  │
└──────────┴──────────┴────────────┘

SUM على الوقت = 5,000 + 6,000 = 11,000 ✗ خطأ!
AVG على الوقت = 5,500 ✓ صحيح
```

---

#### النوع الثالث: Non-Additive Facts (غير قابل للجمع)

**التعريف**: لا يمكن جمعه في أي بُعد! ببساطة: لا تجمع هذه الأرقام أبداً.

**مثال 1: السعر**

```
جدول الأسعار:
┌────────────┬────────┐
│ المنتج     │ السعر  │
├────────────┼────────┤
│ قميص أحمر   │ 100ر.س │
│ قميص أزرق   │ 120ر.س │
│ بنطلون      │ 200ر.س │
└────────────┴────────┘

الخطأ:
SUM = 100 + 120 + 200 = 420 ر.س ✗

هل معنى هذا أن الثمن الكلي 420؟
لا! لو اشتريت قميص + بنطلون = 300 ر.س
(وليس 420)
```

**مثال 2: النسبة المئوية**

```
جدول نسب الخصم:
┌────────────┬──────────┐
│ المنتج     │ الخصم    │
├────────────┼──────────┤
│ أسبوع 1    │ 10%      │
│ أسبوع 2    │ 15%      │
│ أسبوع 3    │ 20%      │
└────────────┴──────────┘

الخطأ:
SUM = 10% + 15% + 20% = 45% ✗

هذا يعني: "الخصم الكلي 45%"؟
ليس بهذه البساطة!

الصحيح:
يجب حساب الخصم المركب
أو تأخذ المتوسط: 15%
```

**مثال 3: درجة الحرارة**

```
درجات الحرارة في الأيام:
┌───────┬──────┐
│التاريخ│ الحرارة
├───────┼──────┤
│الأحد  │ 25°  │
│الإثنين│ 30°  │
└───────┴──────┘

الخطأ:
SUM = 25 + 30 = 55° ✗ بلا معنى

الصحيح:
AVG = 27.5° ✓
أو تأخذ درجة واحدة من يوم معين
```

**الخلاصة للأنواع الثلاثة**:

| النوع | التعريف | مثال | هل تُجمع؟ |
|------|--------|------|---------|
| **Additive** | تُجمع في كل الأبعاد | كمية، إيرادات | نعم في كل مكان |
| **Semi-Additive** | تُجمع في بعض الأبعاد | رصيد، مخزون | نعم لكن ليس بالزمن |
| **Non-Additive** | لا تُجمع | سعر، نسبة، حرارة | لا تُجمع أبداً |

---

## الجزء الثالث: Dimensions بالتفصيل

### مثال عملي شامل: متجر ملابس

#### 1. Dim_Product (بُعد المنتج)

```
Dim_Product:
┌────────┬───────────────────┬──────────┬──────┬──────┬─────────┐
│ProductSK│ProductName        │Category  │Color │Size │ListPrice│
├────────┼───────────────────┼──────────┼──────┼──────┼─────────┤
│ 1      │ قميص قطن أحمر      │ ملابس    │ أحمر │ M    │ 100     │
│ 2      │ قميص حرير أزرق     │ ملابس    │ أزرق │ L    │ 150     │
│ 3      │ بنطلون جينز أسود    │ ملابس    │ أسود │ 32   │ 200     │
│ -999   │ منتج غير معروف     │ غير معروف│ غير │ غير │ 0       │
└────────┴───────────────────┴──────────┴──────┴──────┴─────────┘

ملاحظات:
- ProductSK: الرقم الأساسي (بلا معنى محدد)
- -999: صف خاص للبيانات الناقصة أو المعطوبة
- كل صف = منتج فريد
```

#### 2. Dim_Date (بُعد التاريخ - الخاص جداً!)

```
Dim_Date:
┌─────────┬───────────┬──────┬────────┬───────┬──────────┬────────┬──────────┐
│DateKey  │DateValue  │Year  │Quarter │Month  │DayOfWeek │IsHoliday│IsSale    │
├─────────┼───────────┼──────┼────────┼───────┼──────────┼────────┼──────────┤
│20240101 │2024-01-01 │ 2024 │ Q1     │ يناير │ الاثنين  │ 1      │ 0        │
│20240102 │2024-01-02 │ 2024 │ Q1     │ يناير │ الثلاثاء │ 0      │ 1        │
│20240115 │2024-01-15 │ 2024 │ Q1     │ يناير │ الاثنين  │ 0      │ 0        │
│-999     │NULL       │ -999 │ غير معروف│ غير  │ غير     │ 0      │ 0        │
└─────────┴───────────┴──────┴────────┴───────┴──────────┴────────┴──────────┘

تفاصيل مهمة:
- DateKey بصيغة YYYYMMDD (وليس 1، 2، 3)
- DateValue: التاريخ الفعلي (للربط مع ETL)
- كل أعمدة أخرى: لتسهيل التقارير
- IsHoliday: 1 = إجازة، 0 = يوم عادي
- IsSale: 1 = يوم تخفيفات، 0 = يوم عادي

فائدة:
بدل ما تكتب في كل استعلام:
  EXTRACT(YEAR FROM DateValue) AS Year
  EXTRACT(QUARTER FROM DateValue) AS Quarter
  
تأخذ الأعمدة الجاهزة مباشرة
```

#### 3. Dim_Store (بُعد المتجر)

```
Dim_Store:
┌────────┬──────────────┬──────────┬─────────┬──────────┬───────────┐
│StoreSK │StoreName     │City      │Region   │StoreType │Manager    │
├────────┼──────────────┼──────────┼─────────┼──────────┼───────────┤
│ 1      │ فرع الرياض 1  │ الرياض   │ الوسطى  │ كبير     │ أحمد      │
│ 2      │ فرع الجدة 1   │ الجدة    │ الغربية │ متوسط    │ خديجة     │
│ 3      │ فرع الدمام    │ الدمام   │ الشرقية │ صغير     │ علي       │
│ -999   │ متجر غير معروف│ غير     │ غير     │ غير      │ غير       │
└────────┴──────────────┴──────────┴─────────┴──────────┴───────────┘

استخدام:
عندما تكون في Fact Table:
  StoreKey = 1
→ تعرف: أي متجر في أي مدينة في أي منطقة

يمكنك تحليل المبيعات حسب:
- المدينة
- المنطقة
- نوع المتجر
- المدير
```

#### 4. Dim_Customer (بُعد العميل)

```
Dim_Customer:
┌────────┬────────┬──────────┬─────────┬──────────┬────────────────┐
│CustSK  │CustName│CustType  │City     │Email     │JoinDate        │
├────────┼────────┼──────────┼─────────┼──────────┼────────────────┤
│ 1      │ أحمد   │ عادي     │ الرياض  │a@mail.com│ 2023-01-15     │
│ 2      │ خديجة  │ VIP      │ الجدة   │k@mail.com│ 2022-05-20     │
│ 3      │ علي    │ عادي     │ الدمام  │a2@mail.com│2023-10-01     │
│ -999   │ غير معروف│ غير     │ غير    │ غير      │ 9999-12-31    │
└────────┴────────┴──────────┴─────────┴──────────┴────────────────┘

ملاحظات:
- CustType: يمكنك تحليل المبيعات حسب نوع العميل
- JoinDate: تاريخ انضمام العميل
```

---

### تجميع Dimensions: مثال عملي كامل

```
السؤال: "كم باعنا من الملابس الحمراء يوم الجمعة في الرياض؟"

الخطوات:
1) ابدأ من Fact_Sales
2) صل إلى Dim_Product
   → ابحث عن: Color = "أحمر"
   → خذ ProductKeys المطابقة
3) صل إلى Dim_Date
   → ابحث عن: DayOfWeek = "الجمعة"
   → خذ DateKeys المطابقة
4) صل إلى Dim_Store
   → ابحث عن: City = "الرياض"
   → خذ StoreKeys المطابقة
5) ارجع للـ Fact Table
   → ابحث عن جميع الصفوف التي تطابق:
     - ProductKey في القائمة من الخطوة 2
     - DateKey في القائمة من الخطوة 3
     - StoreKey في القائمة من الخطوة 4
6) اجمع Amount لكل الصفوف المطابقة

SQL (تقريباً):
SELECT SUM(fs.Amount)
FROM Fact_Sales fs
JOIN Dim_Product dp ON fs.ProductKey = dp.ProductSK
JOIN Dim_Date dd ON fs.DateKey = dd.DateKey
JOIN Dim_Store ds ON fs.StoreKey = ds.StoreSK
WHERE dp.Color = 'أحمر'
  AND dd.DayOfWeek = 'الجمعة'
  AND ds.City = 'الرياض'
```

---

## الجزء الرابع: Schemas بالتفصيل

### Star Schema: الرسم والشرح

```
         ┌─────────────┐
         │ Dim_Date    │
         │ - DateKey   │
         │ - Year      │
         │ - Quarter   │
         │ - Month     │
         └─────────────┘
              │
              │ joins
              ↓
┌───────────────┐        ┌──────────────┐
│ Dim_Store     │◄──────►│ Fact_Sales   │◄─────────┐
│ - StoreSK     │ join   │ - DateKey(FK)│          │
│ - StoreName   │        │ - StoreKey(FK)         │
│ - City        │        │ - ProductKey(FK)       │
└───────────────┘        │ - CustKey(FK)          │
                         │ - Amount               │
                         │ - Quantity             │
                         └──────────────┘
                              ▲
                              │ join
                              │
         ┌──────────────┐     │
         │ Dim_Product  │─────┘
         │ - ProductSK  │
         │ - ProductName│
         │ - Color      │
         │ - Size       │
         └──────────────┘
         
         ┌──────────────┐
         │ Dim_Customer │
         │ - CustSK     │
         │ - CustName   │
         │ - CustType   │
         └──────────────┘
```

**التسلسل الهرمي (Hierarchy) مثال**:

```
Dim_Date Hierarchy:
Year (2024)
  └─► Quarter (Q1)
       └─► Month (January)
            └─► Week (Week 2)
                 └─► Day (15-01-2024)

Dim_Product Hierarchy:
Category (ملابس)
  └─► Type (قمصان)
       └─► Brand (ماركة X)
            └─► Color (أحمر)
                 └─► Size (M)
                      └─► Product (Product ID: 123)

يمكنك التحليل في مستويات مختلفة:
"كم باعنا من الملابس سنة 2024؟" → استخدم Year
"كم باعنا من القمصان الحمراء في يناير؟" → استخدم Month + Product
```

---

### Snow Flake Schema: الفرق

```
Star Schema (الحالي):
Fact → Dim_Product (بعمود واحد: Category)

Snowflake Schema:
Fact → Dim_Product → Dim_Category → Dim_Subcategory

مثال:
┌─────────────────┐
│ Dim_Category    │
│ - CatKey        │
│ - CatName       │
└─────────────────┘
        ▲
        │
┌───────┴──────────┐
│ Dim_Subcategory  │
│ - SubCatKey      │
│ - SubCatName     │
│ - CatKey(FK)     │
└──────────────────┘
        ▲
        │
┌───────┴──────────┐
│ Dim_Product      │
│ - ProductKey     │
│ - ProductName    │
│ - SubCatKey(FK)  │
└──────────────────┘
        ▲
        │ FK
┌───────┴──────────┐
│ Fact_Sales       │
│ - ProductKey(FK) │
└──────────────────┘

المشاكل:
1) Joins أكثر = استعلامات أبطأ
2) أصعب على المستخدمين (يجب يعرفوا كل الجداول)
3) توفير مساحة فقط (غير مهم اليوم)

الحل: استخدم Star Schema!
```

---

## الجزء الخامس: الحالات المتقدمة

### Role-Playing Dimensions: الشرح الكامل

**المشكلة الفعلية**:

```
عندنا عمليات إنترنت (Online Orders):

Order_Date: متى وضع العميل الطلب؟
Ship_Date: متى شحنا الطلب؟
Delivery_Date: متى وصل الطلب؟

كل واحد هو تاريخ مختلف!
لكن كلهم يشيرون للـ Dim_Date نفسه!

مثال عملي:
┌──────────┬──────────┬──────────┬───────────┐
│OrderDateKey│ShipDateKey│DeliveryDateKey│OrderID│
├──────────┼──────────┼──────────┼───────────┤
│20240115  │20240116  │20240120  │ORD12345   │
└──────────┴──────────┴──────────┴───────────┘

كل هذه المفاتيح تشير إلى Dim_Date ولكن بأدوار مختلفة!

الحل الخاطئ: إنشاء 3 جداول مختلفة
- Dim_OrderDate
- Dim_ShipDate
- Dim_DeliveryDate

مشاكل:
- نفس البيانات في 3 أماكن
- صيانة معقدة
- تضيع مساحة
- عدم توحد البيانات

الحل الصحيح: استخدام Views (مناظر)

```
جدول واحد:
Dim_Date:
┌─────────┬─────────────┬──────┬───────┐
│DateKey  │DateValue    │Year  │Month  │
├─────────┼─────────────┼──────┼───────┤
│20240115 │2024-01-15   │2024  │01     │
│20240116 │2024-01-16   │2024  │01     │
│20240120 │2024-01-20   │2024  │01     │
└─────────┴─────────────┴──────┴───────┘

ثلاث Views (نوافذ):
vDimOrderDate: نفس البيانات لكن اسم المنظر يشير لـ Order
vDimShipDate: نفس البيانات لكن اسم المنظر يشير لـ Ship
vDimDeliveryDate: نفس البيانات لكن اسم المنظر يشير لـ Delivery

في Fact Table:
ORDER_DATE_SK ← يشير إلى vDimOrderDate (وهي تشير لـ Dim_Date)
SHIP_DATE_SK ← يشير إلى vDimShipDate (وهي تشير لـ Dim_Date)
DELIVERY_DATE_SK ← يشير إلى vDimDeliveryDate (وهي تشير لـ Dim_Date)

الفائدة:
- جدول واحد فقط (توفير مساحة)
- صيانة واحدة
- بيانات موحدة
- عند التقرير، يفهم الناس الفرق بين الأدوار (لأن الأسماء واضحة)
```

---

### Degenerative Dimensions: شرح كامل

**المشكلة والحل**:

```
عمليات البيع لها معرفات فريدة:
- رقم الفاتورة: INV-2024-001
- رقم الطلب: ORD-12345
- رقم التتبع: TRACK-XYZ789

في النظام التشغيلي (OLTP):
هذه أرقام مهمة جداً (تُستخدم في العمليات)

لكن في Dimensional Model:
هل نحتاج بُعد كامل لكل واحد؟ لا!

لماذا؟
- رقم الفاتورة = مجرد معرّف
- لا توجد صفات له (مثل ألوان المنتج)
- لا نحتاج لتحليل حسبه
- لكن نحتفظ به للمراجعة مع النظام الأصلي
```

**الحل العملي**:

```
Fact_Sale:
┌────────┬──────────────┬──────────────┬─────────────────┐
│SaleID  │InvoiceNumber │PurchaseOrder │CarrierTracking  │
├────────┼──────────────┼──────────────┼─────────────────┤
│1       │INV-2024-001  │PO-CUST-123   │TRACK-ABC-789    │
│2       │INV-2024-002  │PO-CUST-124   │TRACK-ABC-790    │
└────────┴──────────────┴──────────────┴─────────────────┘

ملاحظات:
- هذه الأعمدة "degenerative" (منحلة)
- هي Foreign Keys لكن لا توجد Dimension لها
- نحتفظ بها للتدقيق والمراجعة

مثال الاستخدام:
"كل مبيعات من الفاتورة INV-2024-001"
SELECT * FROM Fact_Sale WHERE InvoiceNumber = 'INV-2024-001'

أو للتدقيق:
"هل هذا الطلب موجود في النظام القديم؟"
نبحث عن PurchaseOrder في نظام قديم
```

---

### Factless Facts: تفاصيل كاملة

**المشكلة الحقيقية**:

```
تخيل متجر يريد تتبع:
- من جاء للمتجر
- متى جاء
- من أين جاء

لكن مش كل زائر اشترى شيء!
بعض الناس يتفرجون فقط.

كيف نسجل هذا في Dimensional Model؟
```

**الحل**:

```
Fact_StoreVisit (factless fact):
┌──────┬─────────┬─────────┬───────────┐
│SiteKey│DateKey│CustomerKey│Dummy     │
├──────┼─────────┼─────────┼───────────┤
│1     │20240115│1        │1          │
│1     │20240115│2        │1          │
│2     │20240115│3        │1          │
│1     │20240116│1        │1          │
│2     │20240116│5        │0          │
└──────┴─────────┴─────────┴───────────┘

Dummy = 1: زار المتجر اليوم
Dummy = 0: كان مفروض يزور لكن لم يزر (غياب)

الاستعلامات:
"كم عميل زار المتجر رقم 1 في 2024-01-15؟"
SELECT COUNT(*) FROM Fact_StoreVisit
WHERE SiteKey = 1
  AND DateKey = 20240115
  AND Dummy = 1

"ما نسبة الزيارات للمتجر 1 مقابل المتجر 2؟"
SELECT 
  SiteKey,
  COUNT(*) as Visits
FROM Fact_StoreVisit
GROUP BY SiteKey
```

---

### Conformed Dimensions: الشرح العملي الكامل

**المشكلة الفعلية** (هذه مهمة جداً):

```
شركة كبيرة عندها 3 أنظمة:
1) نظام المبيعات
2) نظام التسويق
3) نظام خدمة العملاء

كل نظام له معرّف عميل مختلف!

نظام المبيعات: 
Customer ID = S-12345

نظام التسويق:
Customer ID = M-ABC123

نظام خدمة العملاء:
Customer ID = C-CUS-789

الآن المدير يقول:
"أريد تقرير عن أحمد: كم اشترى؟ وكم مرة تواصل مع الدعم؟"

المشكلة:
أي معرّف نستخدم؟
وكيف نربط البيانات من الأنظمة الثلاثة؟
```

**الحل: Conformed Dimensions**

```
ننشئ Dim_Customer موحد:

Dim_Customer (واحد فقط، يُستخدم في كل الأنظمة):
┌──────────┬──────────┬─────────────┬─────────────┬─────────────┐
│CustomerSK│CustName  │SalesID      │MarketingID  │SupportID    │
├──────────┼──────────┼─────────────┼─────────────┼─────────────┤
│1         │أحمد      │S-12345      │M-ABC123     │C-CUS-789    │
│2         │خديجة     │S-12346      │M-ABC124     │C-CUS-790    │
└──────────┴──────────┴─────────────┴─────────────┴─────────────┘

الآن:
- Fact_Sales تستخدم CustomerSK = 1
- Fact_Marketing تستخدم CustomerSK = 1
- Fact_Support تستخدم CustomerSK = 1

كلهم يشيرون لـ نفس العميل!

التقرير يصبح سهل:
SELECT
  dc.CustName,
  SUM(fs.Amount) as TotalSales,
  COUNT(fsu.SupportID) as SupportCalls
FROM Dim_Customer dc
LEFT JOIN Fact_Sales fs ON dc.CustomerSK = fs.CustomerSK
LEFT JOIN Fact_Support fsu ON dc.CustomerSK = fsu.CustomerSK
WHERE dc.CustName = 'أحمد'
GROUP BY dc.CustName

الفائدة: بيانات موحدة وموثوقة!
```

---

## الجزء السادس: أمثلة اختبارات محتملة

### مثال 1: السؤال عن أنواع Facts

**السؤال**: 
في جدول الأرصدة البنكية (Bank_Balance):
- شهر يناير: 10,000 ريال
- شهر فبراير: 15,000 ريال
- شهر مارس: 12,000 ريال

ما نوع هذا الـ Fact؟ كيف تُجمع البيانات؟

**الإجابة الصحيحة**:
- النوع: Semi-Additive Fact
- السبب: يمكن جمعها عبر العملاء (مثل: إجمالي أرصدة كل العملاء) لكن ليس عبر الزمن
- الطريقة الصحيحة للتجميع عبر الزمن: AVG = (10,000 + 15,000 + 12,000) / 3 = 12,333 ريال

---

### مثال 2: تصميم Dimensional Model

**السؤال**:
متجر إلكتروني يريد نموذج لتحليل المبيعات. صمم Star Schema يتضمن:
- من اشترى (Customer)
- ماذا اشترى (Product)
- متى اشترى (Date)
- من أي متجر (Store)
- كم الكمية والسعر

**الإجابة**:

```
Fact_OnlineSales:
- SalesKey (PK)
- DateKey (FK → Dim_Date)
- CustomerKey (FK → Dim_Customer)
- ProductKey (FK → Dim_Product)
- StoreKey (FK → Dim_Store)
- Quantity (Additive Measure)
- UnitPrice (Non-Additive)
- LineTotal (Additive)
- Discount (Non-Additive)

Dim_Date:
- DateKey (PK, YYYYMMDD)
- DateValue
- Year, Quarter, Month, DayOfWeek
- IsWeekend, IsHoliday

Dim_Customer:
- CustomerSK (PK)
- CustomerID (NK)
- CustomerName
- City, Country
- JoinDate

Dim_Product:
- ProductSK (PK)
- ProductID (NK)
- ProductName
- Category, SubCategory
- Color, Size

Dim_Store:
- StoreSK (PK)
- StoreName
- City, Country
- StoreType
```

---

### مثال 3: مشكلة في التصميم

**السؤال**:
قارن بين الحلين:

الحل A: استخدام Snowflake Schema
- Product ← SubCategory ← Category
- Date ← Quarter ← Year

الحل B: استخدام Star Schema
- Product (يحتوي على Category و SubCategory)
- Date (يحتوي على Year و Quarter)

أيهما أفضل؟ لماذا؟

**الإجابة**:
- الحل B (Star Schema) أفضل
- السبب: سريع أكثر، سهل على المستخدمين، معيار صناعي
- Snowflake قد يكون أسرع في توفير المساحة فقط (لكن غير مهم اليوم)

---

### مثال 4: Role-Playing Dimensions

**السؤال**:
نموذج مبيعات له ثلاث تواريخ:
1. تاريخ الطلب
2. تاريخ الفاتورة
3. تاريخ الشحن

كيف تعالج هذا في Dimensional Model؟

**الإجابة**:
```
الحل الأمثل:
- جدول Dim_Date واحد فقط
- ثلاث Views: vDimOrderDate, vDimInvoiceDate, vDimShipDate
- في Fact_Sales:
  - OrderDateKey (FK → vDimOrderDate)
  - InvoiceDateKey (FK → vDimInvoiceDate)
  - ShipDateKey (FK → vDimShipDate)

الفوائد:
- توحد البيانات (نفس التواريخ في مكان واحد)
- سهولة الصيانة
- وضوح الأدوار من اسم الـ View
```

---

## الجزء السابع: ملخص نهائي شامل

### جدول المقارنة الشاملة:

| المفهوم | Star | Snowflake | OLAP |
|--------|------|-----------|------|
| **الاستخدام** | 80% من الحالات | نادر جداً | تحليلات معقدة |
| **السرعة** | سريع | أبطأ | الأسرع |
| **السهولة** | سهل | معقد | متوسط |
| **الأبعاد** | غير معايير | معايير | هرمي |
| **الصيانة** | سهل | معقد | متوسط |

### خصائص Additive vs Semi-Additive vs Non-Additive:

| النوع | تُجمع بالزمن | تُجمع بالأبعاد الأخرى | مثال |
|------|-----------|-------------------|------|
| **Additive** | ✓ نعم | ✓ نعم | كمية، إيرادات |
| **Semi-Additive** | ✗ لا (AVG بدلاً من SUM) | ✓ نعم | رصيد، مخزون |
| **Non-Additive** | ✗ لا | ✗ لا | سعر، نسبة |

### نقاط حفظ الاختبار (أهم 10):

1. **Dimensional Modeling** = تصميم لـ BI وليس للعمليات اليومية
2. **Facts** = أرقام (90% من البيانات)
3. **Dimensions** = أوصاف (سياق)
4. **Additive** = يُجمع كل شيء
5. **Semi-Additive** = يُجمع إلا بالزمن
6. **Non-Additive** = لا يُجمع
7. **Star Schema** = الأفضل (Fact + Dimensions)
8. **Snowflake** = نادر (Fact + Normalized Dimensions)
9. **Surrogate Key** = مفتاح بلا معنى للتوحد
10. **Date Dimension** = مفتاحه YYYYMMDD خاص
